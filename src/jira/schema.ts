/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 * @see https://github.com/drwpow/openapi-typescript
 * @see https://redocly.github.io/redoc/?url=https://developer.atlassian.com/cloud/jira/software/on-premise-swagger.json
 */

export interface paths {
  '/rest/builds/0.1/bulk': {
    /**
     * Update / insert builds data.
     *
     * Builds are identified by the combination of `pipelineId` and `buildNumber`, and existing build data for the same
     * build will be replaced if it exists and the `updateSequenceNumber` of the existing data is less than the
     * incoming data.
     *
     * Submissions are performed asynchronously. Submitted data will eventually be available in Jira; most updates are
     * available within a short period of time, but may take some time during peak load and/or maintenance times.
     * The `getBuildByKey` operation can be used to confirm that data has been stored successfully (if needed).
     *
     * In the case of multiple builds being submitted in one request, each is validated individually prior to
     * submission. Details of which build failed submission (if any) are available in the response object.
     *
     * Only on-premise integrations, can access this resource.
     */
    post: operations['submitBuilds']
  }
  '/rest/builds/0.1/bulkByProperties': {
    /**
     * Bulk delete all builds data that match the given request.
     *
     * In addition to the optional `_updateSequenceNumber`, one or more query params must be supplied to specify
     * Properties to delete by. If more than one Property is provided, data will be deleted that matches ALL of the
     * Properties (e.g. treated as an AND).
     *
     * See the documentation for the `submitBuilds` operation for more details.
     *
     * e.g. DELETE /bulkByProperties?accountId=account-123&repoId=repo-345
     *
     * Deletion is performed asynchronously. The `getBuildByKey` operation can be used to confirm that data has been
     * deleted successfully (if needed).
     *
     * Only on-premise integrations apps that define the `build` permission can access this resource.
     */
    delete: operations['deleteBuildsByProperty']
  }
  '/rest/builds/0.1/pipelines/{pipelineId}/builds/{buildNumber}': {
    /**
     * Retrieve the currently stored build data for the given `pipelineId` and `buildNumber` combination.
     *
     * The result will be what is currently stored, ignoring any pending updates or deletes.
     * Only on-premise integrations apps that define the `build` permission can access this resource.
     */
    get: operations['getBuildByKey']
    /**
     * Delete the build data currently stored for the given `pipelineId` and `buildNumber` combination.
     *
     * Deletion is performed asynchronously. The `getBuildByKey` operation can be used to confirm that data has been
     * deleted successfully (if needed).
     *  Only on-premise integrations apps that define the `build` permission can access this resource.
     */
    delete: operations['deleteBuildByKey']
  }
  '/jira/devinfo/0.1/cloud/{cloudId}/bulk': {
    /** Stores development information provided in the request to make it available when viewing issues in JIRA. Existing repository and entity data for the same ID will be replaced if the updateSequenceId of existing data is less than the incoming data. Submissions are performed asynchronously. Submitted data will eventually be available in Jira; most updates are available within a short period of time, but may take some time during peak load and/or maintenance times. */
    post: operations['storeDevelopmentInformation']
  }
  '/jira/devinfo/0.1/cloud/{cloudId}/repository/{repositoryId}': {
    /** For the specified repository ID, retrieves the repository and the most recent 400 development information entities. The result will be what is currently stored, ignoring any pending updates or deletes. */
    get: operations['getRepository']
    /** Deletes the repository data stored by the given ID and all related development information entities. Deletion is performed asynchronously. */
    delete: operations['deleteRepository']
  }
  '/jira/devinfo/0.1/cloud/{cloudId}/bulkByProperties': {
    /** Deletes development information entities which have all the provided properties. Entities will be deleted that match ALL of the properties (i.e. treated as an AND). For example if request is DELETE bulk?accountId=123&projectId=ABC entities which have properties accountId=123 and projectId=ABC will be deleted. Special property '\_updateSequenceId' can be used to delete all entities with updateSequenceId less or equal than the value specified. In addition to the optional '\_updateSequenceId', one or more query params must be supplied to specify properties to delete by. Deletion is performed asynchronously: specified entities will eventually be removed from Jira. */
    delete: operations['deleteByProperties']
  }
  '/jira/devinfo/0.1/cloud/{cloudId}/existsByProperties': {
    /** Checks if development information which have all the provided properties exists. For example, if request is GET existsByProperties?accountId=123&projectId=ABC then result will be positive only if there is at least one entity or repository with both properties accountId=123 and projectId=ABC. Special property '\_updateSequenceId' can be used to filter all entities with updateSequenceId less or equal than the value specified. In addition to the optional '\_updateSequenceId', one or more query params must be supplied to specify properties to search by. */
    get: operations['existsByProperties']
  }
  '/jira/devinfo/0.1/cloud/{cloudId}/repository/{repositoryId}/{entityType}/{entityId}': {
    /** Deletes particular development information entity. Deletion is performed asynchronously. */
    delete: operations['deleteEntity']
  }
  '/rest/deployments/0.1/bulk': {
    /**
     * Update / insert deployment data.
     *
     * Deployments are identified by the combination of `pipelineId`, `environmentId` and `deploymentSequenceNumber`, and existing deployment data for the same deployment will be replaced if it exists and the `updateSequenceNumber` of existing data is less than the incoming data.
     *
     * Submissions are processed asynchronously. Submitted data will eventually be available in Jira. Most updates are available within a short period of time, but may take some time during peak load and/or maintenance times. The `getDeploymentByKey` operation can be used to confirm that data has been stored successfully (if needed).
     *
     * In the case of multiple deployments being submitted in one request, each is validated individually prior to submission. Details of which deployments failed submission (if any) are available in the response object.
     *
     * Only on-premise integrations apps that define the `deployment` permission can access this resource.
     */
    post: operations['submitDeployments']
  }
  '/rest/deployments/0.1/bulkByProperties': {
    /**
     * Bulk delete all deployments that match the given request.
     *
     * In addition to the optional `_updateSequenceNumber`, one or more query params must be supplied to specify the Properties to delete by.
     * If more than one Property is provided, data will be deleted that matches ALL of the Properties (i.e. treated as AND).
     * See the documentation for the `submitDeployments` operation for more details.
     *
     * Example operation: DELETE /bulkByProperties?accountId=account-123&createdBy=user-456
     *
     * Deletion is performed asynchronously. The `getDeploymentByKey` operation can be used to confirm that data has been deleted successfully (if needed).
     *
     * Only on-premise integrations apps that define the `deployment` permission can access this resource.
     */
    delete: operations['deleteDeploymentsByProperty']
  }
  '/rest/deployments/0.1/pipelines/{pipelineId}/environments/{environmentId}/deployments/{deploymentSequenceNumber}': {
    /**
     * Retrieve the currently stored deployment data for the given `pipelineId`, `environmentId` and `deploymentSequenceNumber` combination.
     *
     * The result will be what is currently stored, ignoring any pending updates or deletes.
     *
     * Only on-premise integrations apps that define the `deployment` permission can access this resource.
     */
    get: operations['getDeploymentByKey']
    /**
     * Delete the currently stored deployment data for the given `pipelineId`, `environmentId` and `deploymentSequenceNumber` combination.
     *
     * Deletion is performed asynchronously. The `getDeploymentByKey` operation can be used to confirm that data has been deleted successfully (if needed).
     *
     * Only on-premise integrations apps that define the `deployment` permission can access this resource.
     */
    delete: operations['deleteDeploymentByKey']
  }
}

export interface components {
  schemas: {
    /** Messages supplied in the case of an error. */
    ErrorMessages: components['schemas']['ErrorMessage'][]
    /** A message supplied in the case of an error. */
    ErrorMessage: {
      /** A human-readable message describing the error. */
      message: string
      /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
      errorTraceId?: string
    }
    /** The result of a successful `submitBuilds` request. */
    SubmitBuildsResponse: {
      /**
       * The keys of builds that have been accepted for submission. A build key is a composite key that consists of
       * `pipelineId` and `buildNumber`.
       *
       * A build may be rejected if it was only associated with unknown issue keys, or if the submitted data for that
       * build does not match the required schema.
       *
       * Note that a build that isn't updated due to it's `updateSequenceNumber` being out of order is not
       * considered a failed submission.
       */
      acceptedBuilds?: components['schemas']['BuildKey'][]
      /**
       * Details of builds that have not been accepted for submission.
       *
       * A build may be rejected if it was only associated with unknown issue keys, or if the submitted data for the
       * build does not match the required schema.
       */
      rejectedBuilds?: components['schemas']['RejectedBuild'][]
      /**
       * Issue keys that are not known on this Jira instance (if any).
       *
       * These may be invalid keys (e.g. `UTF-8` is sometimes incorrectly identified as a Jira issue key), or they
       * may be for projects that no longer exist.
       *
       * If a build has been associated with issue keys other than those in this array it will still be stored against
       * those valid keys. If a build was only associated with issue keys deemed to be invalid it won't be persisted.
       */
      unknownIssueKeys?: components['schemas']['IssueKey'][]
    }
    /** The payload used to submit (update / insert) build data. */
    SubmitBuildsRequest: {
      properties?: components['schemas']['Properties']
      /**
       * A list of builds to submit to Jira.
       *
       * Each build may be associated with one or more Jira issue keys, and will be associated with any properties
       * included in this request.
       */
      builds: components['schemas']['BuildData'][]
    }
    /** Data related to a single build */
    BuildData: {
      /**
       * The schema version used for this data.
       *
       * Placeholder to support potential schema changes in the future.
       */
      schemaVersion?: '1.0'
      /**
       * An ID that relates a sequence of builds. Depending on your use case this might be a project ID, pipeline ID,
       * plan key etc. - whatever logical unit you use to group a sequence of builds.
       *
       * The combination of `pipelineId` and `buildNumber` must uniquely identify a build you have provided.
       */
      pipelineId: string
      /**
       * Identifies a build within the sequence of builds identified by the build `pipelineId`.
       *
       * Used to identify the 'most recent' build in that sequence of builds.
       *
       * The combination of `pipelineId` and `buildNumber` must uniquely identify a build you have provided.
       */
      buildNumber: number
      /**
       * A nubmer used to apply an order to the updates to the build, as identified by `pipelineId` and `buildNumber`,
       * in the case of out-of-order receipt of update requests.
       *
       * It must be a monotonically increasing number. For example, epoch time could be one way to generate the
       * `updateSequenceNumber`.
       *
       * Updates for a build that is received with an `updateSqeuenceNumber` less than or equal to what is currently
       * stored will be ignored.
       */
      updateSequenceNumber: number
      /**
       * The human-readable name for the build.
       *
       * Will be shown in the UI.
       */
      displayName: string
      /**
       * An optional description to attach to this build.
       *
       * This may be anything that makes sense in your system.
       */
      description?: string
      /** A human-readable string that to provide information about the build. */
      label?: string
      /** The URL to this build in your system. */
      url: string
      state: components['schemas']['BuildState']
      /** The last-updated timestamp to present to the user as a summary of the state of the build. */
      lastUpdated: string
      /**
       * The Jira issue keys to associate the build information with.
       *
       * You are free to associate issue keys in any way you like. However, we recommend that you use the name
       * of the branch the build was executed on, and extract issue keys from that name using a simple regex. This has
       * the advantage that it provides an intuitive association of builds to issue keys.
       */
      issueKeys: components['schemas']['IssueKey'][]
      testInfo?: components['schemas']['TestInfo']
      /** Optional information that links a build to a commit, branch etc. */
      references?: components['schemas']['BuildReferences'][]
    }
    /** Fields that uniquely reference a build. */
    BuildKey: {
      /**
       * An ID that relates a sequence of builds. Depending on your system this might be a project ID, pipeline ID,
       * plan key etc. - whatever logical unit you use to group a sequence of builds.
       *
       * The combination of `pipelineId` and `buildNumber` must uniquely identify the build.
       */
      pipelineId: string
      /**
       * Identifies a build within the sequence of builds identified by the build `pipelineId`.
       *
       * Used to identify the 'most recent' build in that sequence of builds.
       *
       * The combination of `pipelineId` and `buildNumber` must uniquely identify the build.
       */
      buildNumber: number
    }
    /**
     * The state of a build.
     *
     * * `pending` - The build is queued, or some manual action is required.
     * * `in_progress` - The build is currently running.
     * * `successful` - The build completed successfully.
     * * `failed` - The build failed.
     * * `cancelled` - The build has been cancelled or stopped.
     * * `unknown` - The build is in an unknown state.
     */
    BuildState:
      | 'pending'
      | 'in_progress'
      | 'successful'
      | 'failed'
      | 'cancelled'
      | 'unknown'
    /** Information about tests that were executed during a build. */
    TestInfo: {
      /** The total number of tests considered during a build. */
      totalNumber: number
      /** The number of tests that passed during a build. */
      numberPassed: number
      /** The number of tests that failed during a build. */
      numberFailed: number
      /** The number of tests that were skipped during a build. */
      numberSkipped?: number
    }
    /**
     * Information that links a build to a commit, branch etc.
     *
     * Used to provide a richer user experience by enabling us to associate builds from your system with e.g.
     * branches / commits / tags etc. supplied by another app in the Jira UI.
     */
    BuildReferences: {
      commit?: components['schemas']['BuildCommitReference']
      ref?: components['schemas']['BuildRefReference']
    }
    /** Details about the commit the build was run against. */
    BuildCommitReference: {
      /** The ID of the commit. E.g. for a Git repository this would be the SHA1 hash. */
      id: string
      /**
       * An identifier for the repository containing the commit.
       *
       * In most cases this should be the URL of the repository in the SCM provider.
       *
       * For cases where the build was executed against a local repository etc. this should be some identifier that is
       * unique to that repository.
       */
      repositoryUri: string
    }
    /** Details about the ref the build was run on. */
    BuildRefReference: {
      /** The name of the ref the build ran on */
      name: string
      /**
       * An identifer for the ref.
       *
       * In most cases this should be the URL of the tag/branch etc. in the SCM provider.
       *
       * For cases where the build was executed against a local repository etc. this should be something that uniquely
       * identifies the ref.
       */
      uri: string
    }
    /**
     * Properties assigned to build data that can then be used for delete / query operations.
     *
     * Examples might be an account or user ID that can then be used to clean up data if an account is removed from
     * the Provider system.
     *
     * Properties are supplied as key/value pairs, a maximum of 5 properties can be supplied, and keys must not
     * contain ':' or start with '_'.
     */
    Properties: {[key: string]: string}
    /** An issue key that references an issue in Jira. */
    IssueKey: string
    /**
     * A build that has not been accepted for submission, usually due to a problem with the request data.
     *
     * The object is comprised of the key of the rejected build and the corresponding error messages.
     */
    RejectedBuild: {
      key: components['schemas']['BuildKey']
      /** The error messages for the rejected build */
      errors: components['schemas']['ErrorMessage'][]
    }
    /** The result of a successful submitDeployments request. */
    SubmitDeploymentsResponse: {
      /**
       * The keys of deployments that have been accepted for submission. A deployment key is a composite key that consists of `pipelineId`, `environmentId` and `deploymentSequenceNumber`.
       *
       * A deployment may be rejected if it was only associated with unknown issue keys.
       *
       * Note that a deployment that isn't updated due to it's updateSequenceNumber being out of order is not considered a failed submission.
       */
      acceptedDeployments?: components['schemas']['DeploymentKey'][]
      /**
       * Details of deployments that have not been accepted for submission, usually due to a problem with the request data.
       *
       * The object will contain the deployment key and any errors associated with that deployment that have prevented it being submitted.
       */
      rejectedDeployments?: components['schemas']['RejectedDeployment'][]
      /**
       * Issue keys that are not known on this Jira instance (if any).
       *
       * These may be invalid keys (e.g. `UTF-8` is sometimes incorrectly identified as a Jira issue key), or they may be for projects that no longer exist.
       *
       * If a deployment has been associated with issue keys other than those in this array it will still be stored against those valid keys.
       * If a deployment was only associated with issue keys deemed to be invalid it won't be persisted.
       */
      unknownIssueKeys?: components['schemas']['IssueKey'][]
    }
    /** The payload used to submit (update / insert) deployment data. */
    SubmitDeploymentRequest: {
      properties?: components['schemas']['Properties']
      /**
       * A list of deployments to submit to Jira.
       *
       * Each deployment may be associated with one or more Jira issue keys, and will be associated with any properties included in this request.
       */
      deployments: components['schemas']['DeploymentData'][]
    }
    /** Data related to a specific deployment in a specific environment that the deployment is present in. */
    DeploymentData: {
      /** This is the identifier for the deployment. It must be unique for the specified pipeline and environment. It must be a monotonically increasing number, as this is used to sequence the deployments. */
      deploymentSequenceNumber: number
      /** A number used to apply an order to the updates to the deployment, as identified by the deploymentSequenceNumber, in the case of out-of-order receipt of update requests. It must be a monotonically increasing number. For example, epoch time could be one way to generate the updateSequenceNumber. */
      updateSequenceNumber: number
      /** The Jira issue keys to associate the deployment information with. */
      issueKeys: components['schemas']['IssueKey'][]
      /** The human-readable name for the deployment. Will be shown in the UI. */
      displayName: string
      /** A URL users can use to link to this deployment, in this environment. */
      url: string
      /** A short description of the deployment */
      description: string
      /** The last-updated timestamp to present to the user as a summary of the state of the deployment. */
      lastUpdated: string
      /** An (optional) additional label that may be displayed with deployment information. Can be used to display version information etc. for the deployment. */
      label?: string
      /** The state of the deployment */
      state:
        | 'unknown'
        | 'pending'
        | 'in_progress'
        | 'cancelled'
        | 'failed'
        | 'rolled_back'
        | 'successful'
      pipeline: components['schemas']['Pipeline']
      environment: components['schemas']['Environment']
      /**
       * The DeploymentData schema version used for this deployment data.
       *
       * Placeholder to support potential schema changes in the future.
       */
      schemaVersion?: '1.0'
    }
    /**
     * This object models the Continuous Delivery (CD) Pipeline concept, an automated process (usually comprised of multiple stages)
     * for getting software from version control right through to the production environment.
     */
    Pipeline: {
      /** The identifier of this pipeline, must be unique for the provider. */
      id: string
      /** The name of the pipeline to present to the user. */
      displayName: string
      /** A URL users can use to link to this deployment pipeline. */
      url: string
    }
    /** The environment that the deployment is present in. */
    Environment: {
      /** The identifier of this environment, must be unique for the provider so that it can be shared across pipelines. */
      id: string
      /** The name of the environment to present to the user. */
      displayName: string
      /** The type of the environment. */
      type: 'unmapped' | 'development' | 'testing' | 'staging' | 'production'
    }
    /** Fields that uniquely reference a deployment. */
    DeploymentKey: {
      /** The identifier of a pipeline, must be unique for the provider. */
      pipelineId: string
      /** The identifier of an environment, must be unique for the provider so that it can be shared across pipelines. */
      environmentId: string
      /** This is the identifier for the deployment. It must be unique for the specified pipeline and environment. It must be a monotonically increasing number, as this is used to sequence the deployments. */
      deploymentSequenceNumber: number
    }
    /**
     * A deployment that has not been accepted for submission, usually due to a problem with the request data.
     *
     * The object is comprised of the key of the rejected deployment and the corresponding error messages.
     */
    RejectedDeployment: {
      key: components['schemas']['DeploymentKey']
      /** The error messages for the rejected deployment */
      errors: components['schemas']['ErrorMessage'][]
    }
  }
  requestBodies: {}
}

export interface operations {
  /**
   * Update / insert builds data.
   *
   * Builds are identified by the combination of `pipelineId` and `buildNumber`, and existing build data for the same
   * build will be replaced if it exists and the `updateSequenceNumber` of the existing data is less than the
   * incoming data.
   *
   * Submissions are performed asynchronously. Submitted data will eventually be available in Jira; most updates are
   * available within a short period of time, but may take some time during peak load and/or maintenance times.
   * The `getBuildByKey` operation can be used to confirm that data has been stored successfully (if needed).
   *
   * In the case of multiple builds being submitted in one request, each is validated individually prior to
   * submission. Details of which build failed submission (if any) are available in the response object.
   *
   * Only on-premise integrations, can access this resource.
   */
  submitBuilds: {
    responses: {
      /**
       * Submission accepted. Each submitted build that is of a valid format will be eventually available in Jira.
       *
       * Details of which builds were submitted and which failed submission (due to data format problems etc.)
       * are available in the response object.
       */
      202: {
        content: {
          'application/json': components['schemas']['SubmitBuildsResponse']
        }
      }
      /**
       * Request has incorrect format.
       *
       * Note that in the case of an individual build having an invalid format (rather than the request as a whole)
       * the response for the request will be a 202 and details of the invalid build will be contained in the
       * response object.
       */
      400: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
      /** Missing a OAuth token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `build` permission. */
      403: unknown
      /** Data is too large. Submit fewer builds in each payload. */
      413: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
      /** API rate limit has been exceeded. */
      429: unknown
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
      /** An unknown error has occurred. */
      default: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
    }
    /** Builds data to submit. */
    requestBody: {
      content: {
        'application/json': components['schemas']['SubmitBuildsRequest']
      }
    }
  }
  /**
   * Bulk delete all builds data that match the given request.
   *
   * In addition to the optional `_updateSequenceNumber`, one or more query params must be supplied to specify
   * Properties to delete by. If more than one Property is provided, data will be deleted that matches ALL of the
   * Properties (e.g. treated as an AND).
   *
   * See the documentation for the `submitBuilds` operation for more details.
   *
   * e.g. DELETE /bulkByProperties?accountId=account-123&repoId=repo-345
   *
   * Deletion is performed asynchronously. The `getBuildByKey` operation can be used to confirm that data has been
   * deleted successfully (if needed).
   *
   * Only on-premise integrations apps that define the `build` permission can access this resource.
   */
  deleteBuildsByProperty: {
    parameters: {
      query: {
        /**
         * An optional `updateSequenceNumber` to use to control deletion.
         *
         * Only stored data with an `updateSequenceNumber` less than or equal to that provided will be deleted.
         * This can be used help ensure submit/delete requests are applied correctly if issued close together.
         *
         * If not provided, all stored data that matches the request will be deleted.
         */
        _updateSequenceNumber?: number
      }
    }
    responses: {
      /** Delete accepted. Data will eventually be removed from Jira. */
      202: unknown
      /** Request has incorrect format (e.g. missing at least one Property param). */
      400: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
      /** Missing a  token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `build` permission. */
      403: unknown
      /** API rate limit has been exceeded. */
      429: unknown
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
      /** An unknown error has occurred. */
      default: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
    }
  }
  /**
   * Retrieve the currently stored build data for the given `pipelineId` and `buildNumber` combination.
   *
   * The result will be what is currently stored, ignoring any pending updates or deletes.
   * Only on-premise integrations apps that define the `build` permission can access this resource.
   */
  getBuildByKey: {
    parameters: {
      path: {
        /** The `pipelineId` of the build. */
        pipelineId: string
        /** The `buildNumber` of the build. */
        buildNumber: number
      }
    }
    responses: {
      /** The build data currently stored for the given key. */
      200: {
        content: {
          'application/json': components['schemas']['BuildData']
        }
      }
      /** Missing a OAuth token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `build` permission. */
      403: unknown
      /** No build data found for the given key. */
      404: unknown
      /** API rate limit has been exceeded. */
      429: unknown
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
      /** An unknown error has occurred. */
      default: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
    }
  }
  /**
   * Delete the build data currently stored for the given `pipelineId` and `buildNumber` combination.
   *
   * Deletion is performed asynchronously. The `getBuildByKey` operation can be used to confirm that data has been
   * deleted successfully (if needed).
   *  Only on-premise integrations apps that define the `build` permission can access this resource.
   */
  deleteBuildByKey: {
    parameters: {
      path: {
        /** The `pipelineId` of the build to delete. */
        pipelineId: string
        /** The `buildNumber` of the build to delete. */
        buildNumber: number
      }
      query: {
        /**
         * An optional `updateSequenceNumber` to use to control deletion.
         *
         * Only stored data with an `updateSequenceNumber` less than or equal to that provided will be deleted.
         * This can be used help ensure submit/delete requests are applied correctly if issued close together.
         */
        _updateSequenceNumber?: number
      }
    }
    responses: {
      /** Delete has been accepted. Data will eventually be removed from Jira if it exists. */
      202: unknown
      /** Missing a OAuth token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `build` permission. */
      403: unknown
      /** API rate limit has been exceeded. */
      429: unknown
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
      /** An unknown error has occurred. */
      default: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
    }
  }
  /** Stores development information provided in the request to make it available when viewing issues in JIRA. Existing repository and entity data for the same ID will be replaced if the updateSequenceId of existing data is less than the incoming data. Submissions are performed asynchronously. Submitted data will eventually be available in Jira; most updates are available within a short period of time, but may take some time during peak load and/or maintenance times. */
  storeDevelopmentInformation: {
    parameters: {
      path: {
        /** The cloud ID of the site. This can be retrieved by using http://your-site.atlassian.net/_edge/tenant_info */
        cloudId: string
      }
    }
    responses: {
      /** Submission accepted. Each submitted repository and entity that is of a valid format will be eventually available in Jira. */
      202: {
        content: {
          'application/json': {
            /** The IDs of devinfo entities that have been accepted for submission grouped by their repository ids. Note that a devinfo entity that isn't updated due to it's updateSequenceId being out of order is not considered a failed submission. */
            acceptedDevinfoEntities?: {
              [key: string]: {
                /** Commits ids */
                commits?: string[]
                /** Branches ids */
                branches?: string[]
                /** Pull requests ids */
                pullRequests?: string[]
              }
            }
            /** IDs of devinfo entities that have not been accepted for submission and caused error descriptions, usually due to a problem with the request data. The entities (if present) will be grouped by their repository id and type. Entity IDs are listed with errors associated with that devinfo entity that have prevented it being submitted. */
            failedDevinfoEntities?: {
              [key: string]: {
                /** Repository errors */
                errorMessages?: {
                  /** A human-readable message describing the error. */
                  message: string
                  /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
                  errorTraceId?: string
                }[]
                /** Commits errors */
                commits?: {
                  /** Entity id */
                  id: string
                  /** Error message */
                  errorMessages?: {
                    /** A human-readable message describing the error. */
                    message: string
                    /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
                    errorTraceId?: string
                  }[]
                }[]
                /** Branches errors */
                branches?: {
                  /** Entity id */
                  id: string
                  /** Error message */
                  errorMessages?: {
                    /** A human-readable message describing the error. */
                    message: string
                    /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
                    errorTraceId?: string
                  }[]
                }[]
                /** Pull requests errors */
                pullRequests?: {
                  /** Entity id */
                  id: string
                  /** Error message */
                  errorMessages?: {
                    /** A human-readable message describing the error. */
                    message: string
                    /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
                    errorTraceId?: string
                  }[]
                }[]
              }
            }
            /** Issue keys that are not known on this Jira instance (if any). These may be invalid keys (e.g. `UTF-8` is sometimes incorrectly identified as a Jira issue key), or they may be for projects that no longer exist. If a devinfo entity has been associated with issue keys other than those in this array it will still be stored against those valid keys. */
            unknownIssueKeys?: string[]
          }
        }
      }
      /** Request has incorrect format. It will fail in the following cases: If no repositories or development information entities were provided, or more than 5 properties were submitted, or there are one or more properties with leading underscore '_' symbol in their keys. */
      400: {
        content: {
          'application/json': {
            /** List of errors occurred. */
            errorMessages: {
              /** A human-readable message describing the error. */
              message: string
              /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
              errorTraceId?: string
            }[]
          }
        }
      }
      /** Missing a OAuth token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `development information` permission. */
      403: unknown
      /** Data is too large. Submit fewer devinfo entities in each payload. */
      413: {
        content: {
          'application/json': {
            /** List of errors occurred. */
            errorMessages: {
              /** A human-readable message describing the error. */
              message: string
              /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
              errorTraceId?: string
            }[]
          }
        }
      }
      /** API rate limit has been exceeded. */
      429: unknown
      /** An unknown error has occurred. */
      500: {
        content: {
          'application/json': {
            /** List of errors occurred. */
            errorMessages: {
              /** A human-readable message describing the error. */
              message: string
              /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
              errorTraceId?: string
            }[]
          }
        }
      }
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
    }
    /** Request object, which contains development information */
    requestBody: {
      content: {
        'application/json': {
          /** List of repositories containing development information. Must not contain duplicates. Maximum number of entities across all repositories is 1000 */
          repositories: {
            /** The name of this repository. Max length is 255 characters */
            name: string
            /** Description of this repository. Max length is 1024 characters */
            description?: string
            /** The ID of the repository this repository was forked from, if it's a fork. Max length is 255 characters */
            forkOf?: string
            /** The URL of this repository. Max length is 1024 characters */
            url: string
            /** List of commits to update in this repository. Must not contain duplicate entity IDs. Maximum number of commits is 400 */
            commits?: {
              /** The ID of this entity. Will be used for cross entity linking. Must be unique by entity type within a repository, i.e., only one commit can have ID 'X' in repository 'Y'. But adding, e.g., a branch with ID 'X' to repository 'Y' is acceptable. Only alphanumeric characters, and '~.-_', are allowed. Max length is 1024 characters */
              id: string
              /** List of issues keys that this entity is associated with. They must be valid JIRA issue keys. Minimum number of issue keys is 1. Maximum number of issue keys is 100 */
              issueKeys: string[]
              /** An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored. */
              updateSequenceId: number
              /** The hash of the commit. Max length is 255 characters */
              hash: string
              /** The set of flags for this commit */
              flags?: 'MERGE_COMMIT'[]
              /** The commit message. Max length is 1024 characters */
              message: string
              /** The author of this commit */
              author: {
                /** The name of this user in a format suitable for display. Max length is 255 characters */
                name: string
                /** The email address of the user, used to associate the user with a JIRA user. Max length is 255 characters */
                email?: string
                /** The username of the user, used to associate the user with a JIRA user if there are multiple users for a given email. Max length is 255 characters */
                username?: string
                /** The URL of the profile for this user. Max length is 1024 characters */
                url?: string
                /** The URL of the avatar for this user. Max length is 1024 characters */
                avatar?: string
              }
              /** The total number of files added, removed, or modified by this commit */
              fileCount: number
              /** The URL of this commit. Max length is 1024 characters */
              url: string
              /** List of file changes. Max number of files is 10. Currently, only the first 5 files are shown (sorted by path) in the UI. This UI behavior may change without notice */
              files?: {
                /** The path of the file. Max length is 1024 characters */
                path: string
                /** The URL of this file. Max length is 1024 characters */
                url: string
                /** The operation performed on this file */
                changeType:
                  | 'ADDED'
                  | 'COPIED'
                  | 'DELETED'
                  | 'MODIFIED'
                  | 'MOVED'
                  | 'UNKNOWN'
                /** Number of lines added to the file */
                linesAdded: number
                /** Number of lines removed from the file */
                linesRemoved: number
              }[]
              /** The author timestamp of this commit. Formatted as a UTC ISO 8601 date time format */
              authorTimestamp: string
              /** Shortened identifier for this commit, used for display. Max length is 255 characters */
              displayId: string
            }[]
            /** List of branches to update in this repository. Must not contain duplicate entity IDs. Maximum number of commits is 400 */
            branches?: {
              /** The ID of this entity. Will be used for cross entity linking. Must be unique by entity type within a repository, i.e., only one commit can have ID 'X' in repository 'Y'. But adding, e.g., a branch with ID 'X' to repository 'Y' is acceptable. Only alphanumeric characters, and '~.-_', are allowed. Max length is 1024 characters */
              id: string
              /** List of issues keys that this entity is associated with. They must be valid JIRA issue keys. Minimum number of issue keys is 1. Maximum number of issue keys is 100 */
              issueKeys: string[]
              /** An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored. */
              updateSequenceId: number
              /** The name of the branch. Max length is 255 characters */
              name: string
              /** The most recent commit on this branch, used to display the date of the latest activity for this branch */
              lastCommit: {
                /** The ID of this entity. Will be used for cross entity linking. Must be unique by entity type within a repository, i.e., only one commit can have ID 'X' in repository 'Y'. But adding, e.g., a branch with ID 'X' to repository 'Y' is acceptable. Only alphanumeric characters, and '~.-_', are allowed. Max length is 1024 characters */
                id: string
                /** List of issues keys that this entity is associated with. They must be valid JIRA issue keys. Minimum number of issue keys is 1. Maximum number of issue keys is 100 */
                issueKeys: string[]
                /** An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored. */
                updateSequenceId: number
                /** The hash of the commit. Max length is 255 characters */
                hash: string
                /** The set of flags for this commit */
                flags?: 'MERGE_COMMIT'[]
                /** The commit message. Max length is 1024 characters */
                message: string
                /** The author of this commit */
                author: {
                  /** The name of this user in a format suitable for display. Max length is 255 characters */
                  name: string
                  /** The email address of the user, used to associate the user with a JIRA user. Max length is 255 characters */
                  email?: string
                  /** The username of the user, used to associate the user with a JIRA user if there are multiple users for a given email. Max length is 255 characters */
                  username?: string
                  /** The URL of the profile for this user. Max length is 1024 characters */
                  url?: string
                  /** The URL of the avatar for this user. Max length is 1024 characters */
                  avatar?: string
                }
                /** The total number of files added, removed, or modified by this commit */
                fileCount: number
                /** The URL of this commit. Max length is 1024 characters */
                url: string
                /** List of file changes. Max number of files is 10. Currently, only the first 5 files are shown (sorted by path) in the UI. This UI behavior may change without notice */
                files?: {
                  /** The path of the file. Max length is 1024 characters */
                  path: string
                  /** The URL of this file. Max length is 1024 characters */
                  url: string
                  /** The operation performed on this file */
                  changeType:
                    | 'ADDED'
                    | 'COPIED'
                    | 'DELETED'
                    | 'MODIFIED'
                    | 'MOVED'
                    | 'UNKNOWN'
                  /** Number of lines added to the file */
                  linesAdded: number
                  /** Number of lines removed from the file */
                  linesRemoved: number
                }[]
                /** The author timestamp of this commit. Formatted as a UTC ISO 8601 date time format */
                authorTimestamp: string
                /** Shortened identifier for this commit, used for display. Max length is 255 characters */
                displayId: string
              }
              /** The URL of the page for creating a pull request from this branch. Max length is 1024 characters */
              createPullRequestUrl?: string
              /** The URL of the branch. Max length is 1024 characters */
              url: string
            }[]
            /** List of pull requests to update in this repository. Must not contain duplicate entity IDs. Maximum number of commits is 400 */
            pullRequests?: {
              /** The ID of this entity. Will be used for cross entity linking. Must be unique by entity type within a repository, i.e., only one commit can have ID 'X' in repository 'Y'. But adding, e.g., a branch with ID 'X' to repository 'Y' is acceptable. Only alphanumeric characters, and '~.-_', are allowed. Max length is 1024 characters */
              id: string
              /** List of issues keys that this entity is associated with. They must be valid JIRA issue keys. Minimum number of issue keys is 1. Maximum number of issue keys is 100 */
              issueKeys: string[]
              /** An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored. */
              updateSequenceId: number
              /** The status of the pull request. In the case of concurrent updates, priority is given in the order OPEN, MERGED, DECLINED, UNKNOWN */
              status: 'OPEN' | 'MERGED' | 'DECLINED' | 'UNKNOWN'
              /** Title of the pull request. Max length is 1024 characters */
              title: string
              /** The author of this pull request */
              author: {
                /** The name of this user in a format suitable for display. Max length is 255 characters */
                name: string
                /** The email address of the user, used to associate the user with a JIRA user. Max length is 255 characters */
                email?: string
                /** The username of the user, used to associate the user with a JIRA user if there are multiple users for a given email. Max length is 255 characters */
                username?: string
                /** The URL of the profile for this user. Max length is 1024 characters */
                url?: string
                /** The URL of the avatar for this user. Max length is 1024 characters */
                avatar?: string
              }
              /** The number of comments on the pull request */
              commentCount: number
              /** The name of the source branch of this PR. Max length is 255 characters */
              sourceBranch: string
              /** The url of the source branch of this PR. This is used to match this PR against the branch. Max length is 255 characters */
              sourceBranchUrl?: string
              /** The most recent update to this PR. Formatted as a UTC ISO 8601 date time format */
              lastUpdate: string
              /** The name of destination branch of this PR. Max length is 255 characters */
              destinationBranch?: string
              /** The list of reviewers of this pull request */
              reviewers?: {
                /** The name of this reviewer. Max length is 255 characters */
                name: string
                /** The approval status of this reviewer, default is UNAPPROVED */
                approvalStatus?: 'APPROVED' | 'UNAPPROVED'
                /** The URL of the profile for this reviewer. Max length is 1024 characters */
                url?: string
                /** The URL of the avatar for this reviewer. Max length is 1024 characters */
                avatar?: string
              }[]
              /** The URL of this pull request. Max length is 1024 characters */
              url: string
              /** Shortened identifier for this pull request, used for display. Max length is 255 characters */
              displayId: string
            }[]
            /** The URL of the avatar for this repository. Max length is 1024 characters */
            avatar?: string
            /** Description of the avatar for this repository. Max length is 1024 characters */
            avatarDescription?: string
            /** The ID of this entity. Will be used for cross entity linking. Must be unique by entity type within a repository, i.e., only one commit can have ID 'X' in repository 'Y'. But adding, e.g., a branch with ID 'X' to repository 'Y' is acceptable. Only alphanumeric characters, and '~.-_', are allowed. Max length is 1024 characters */
            id: string
            /** An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored. */
            updateSequenceId: number
          }[]
          /** Flag to prevent automatic issue transitions and smart commits being fired, default is false */
          preventTransitions?: boolean
          /** Arbitrary properties to tag the submitted repositories with. These properties can be used for delete operations to e.g. clean up all development information associated with an account in the event that the account is removed from the provider system. Note that these properties will never be returned with repository or entity data. They are not intended for use as metadata to associate with a repository. Maximum length of each key or value is 255 characters. Maximum allowed number of properties key/value pairs is 5. Properties keys cannot start with '_' character. Properties keys cannot contain ':' character. */
          properties?: {[key: string]: string}
          /** Details about the provider */
          providerMetadata?: {
            /** The product sending data */
            product: string
          }
        }
      }
    }
  }
  /** For the specified repository ID, retrieves the repository and the most recent 400 development information entities. The result will be what is currently stored, ignoring any pending updates or deletes. */
  getRepository: {
    parameters: {
      path: {
        /** The cloud ID of the site. */
        cloudId: string
        /** The ID of repository to fetch */
        repositoryId: string
      }
    }
    responses: {
      /** The repository data currently stored for the given ID. */
      200: {
        content: {
          'application/json': {
            /** The name of this repository. Max length is 255 characters */
            name: string
            /** Description of this repository. Max length is 1024 characters */
            description?: string
            /** The ID of the repository this repository was forked from, if it's a fork. Max length is 255 characters */
            forkOf?: string
            /** The URL of this repository. Max length is 1024 characters */
            url: string
            /** List of commits to update in this repository. Must not contain duplicate entity IDs. Maximum number of commits is 400 */
            commits?: {
              /** The ID of this entity. Will be used for cross entity linking. Must be unique by entity type within a repository, i.e., only one commit can have ID 'X' in repository 'Y'. But adding, e.g., a branch with ID 'X' to repository 'Y' is acceptable. Only alphanumeric characters, and '~.-_', are allowed. Max length is 1024 characters */
              id: string
              /** List of issues keys that this entity is associated with. They must be valid JIRA issue keys. Minimum number of issue keys is 1. Maximum number of issue keys is 100 */
              issueKeys: string[]
              /** An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored. */
              updateSequenceId: number
              /** The hash of the commit. Max length is 255 characters */
              hash: string
              /** The set of flags for this commit */
              flags?: 'MERGE_COMMIT'[]
              /** The commit message. Max length is 1024 characters */
              message: string
              /** The author of this commit */
              author: {
                /** The name of this user in a format suitable for display. Max length is 255 characters */
                name: string
                /** The email address of the user, used to associate the user with a JIRA user. Max length is 255 characters */
                email?: string
                /** The username of the user, used to associate the user with a JIRA user if there are multiple users for a given email. Max length is 255 characters */
                username?: string
                /** The URL of the profile for this user. Max length is 1024 characters */
                url?: string
                /** The URL of the avatar for this user. Max length is 1024 characters */
                avatar?: string
              }
              /** The total number of files added, removed, or modified by this commit */
              fileCount: number
              /** The URL of this commit. Max length is 1024 characters */
              url: string
              /** List of file changes. Max number of files is 10. Currently, only the first 5 files are shown (sorted by path) in the UI. This UI behavior may change without notice */
              files?: {
                /** The path of the file. Max length is 1024 characters */
                path: string
                /** The URL of this file. Max length is 1024 characters */
                url: string
                /** The operation performed on this file */
                changeType:
                  | 'ADDED'
                  | 'COPIED'
                  | 'DELETED'
                  | 'MODIFIED'
                  | 'MOVED'
                  | 'UNKNOWN'
                /** Number of lines added to the file */
                linesAdded: number
                /** Number of lines removed from the file */
                linesRemoved: number
              }[]
              /** The author timestamp of this commit. Formatted as a UTC ISO 8601 date time format */
              authorTimestamp: string
              /** Shortened identifier for this commit, used for display. Max length is 255 characters */
              displayId: string
            }[]
            /** List of branches to update in this repository. Must not contain duplicate entity IDs. Maximum number of commits is 400 */
            branches?: {
              /** The ID of this entity. Will be used for cross entity linking. Must be unique by entity type within a repository, i.e., only one commit can have ID 'X' in repository 'Y'. But adding, e.g., a branch with ID 'X' to repository 'Y' is acceptable. Only alphanumeric characters, and '~.-_', are allowed. Max length is 1024 characters */
              id: string
              /** List of issues keys that this entity is associated with. They must be valid JIRA issue keys. Minimum number of issue keys is 1. Maximum number of issue keys is 100 */
              issueKeys: string[]
              /** An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored. */
              updateSequenceId: number
              /** The name of the branch. Max length is 255 characters */
              name: string
              /** The most recent commit on this branch, used to display the date of the latest activity for this branch */
              lastCommit: {
                /** The ID of this entity. Will be used for cross entity linking. Must be unique by entity type within a repository, i.e., only one commit can have ID 'X' in repository 'Y'. But adding, e.g., a branch with ID 'X' to repository 'Y' is acceptable. Only alphanumeric characters, and '~.-_', are allowed. Max length is 1024 characters */
                id: string
                /** List of issues keys that this entity is associated with. They must be valid JIRA issue keys. Minimum number of issue keys is 1. Maximum number of issue keys is 100 */
                issueKeys: string[]
                /** An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored. */
                updateSequenceId: number
                /** The hash of the commit. Max length is 255 characters */
                hash: string
                /** The set of flags for this commit */
                flags?: 'MERGE_COMMIT'[]
                /** The commit message. Max length is 1024 characters */
                message: string
                /** The author of this commit */
                author: {
                  /** The name of this user in a format suitable for display. Max length is 255 characters */
                  name: string
                  /** The email address of the user, used to associate the user with a JIRA user. Max length is 255 characters */
                  email?: string
                  /** The username of the user, used to associate the user with a JIRA user if there are multiple users for a given email. Max length is 255 characters */
                  username?: string
                  /** The URL of the profile for this user. Max length is 1024 characters */
                  url?: string
                  /** The URL of the avatar for this user. Max length is 1024 characters */
                  avatar?: string
                }
                /** The total number of files added, removed, or modified by this commit */
                fileCount: number
                /** The URL of this commit. Max length is 1024 characters */
                url: string
                /** List of file changes. Max number of files is 10. Currently, only the first 5 files are shown (sorted by path) in the UI. This UI behavior may change without notice */
                files?: {
                  /** The path of the file. Max length is 1024 characters */
                  path: string
                  /** The URL of this file. Max length is 1024 characters */
                  url: string
                  /** The operation performed on this file */
                  changeType:
                    | 'ADDED'
                    | 'COPIED'
                    | 'DELETED'
                    | 'MODIFIED'
                    | 'MOVED'
                    | 'UNKNOWN'
                  /** Number of lines added to the file */
                  linesAdded: number
                  /** Number of lines removed from the file */
                  linesRemoved: number
                }[]
                /** The author timestamp of this commit. Formatted as a UTC ISO 8601 date time format */
                authorTimestamp: string
                /** Shortened identifier for this commit, used for display. Max length is 255 characters */
                displayId: string
              }
              /** The URL of the page for creating a pull request from this branch. Max length is 1024 characters */
              createPullRequestUrl?: string
              /** The URL of the branch. Max length is 1024 characters */
              url: string
            }[]
            /** List of pull requests to update in this repository. Must not contain duplicate entity IDs. Maximum number of commits is 400 */
            pullRequests?: {
              /** The ID of this entity. Will be used for cross entity linking. Must be unique by entity type within a repository, i.e., only one commit can have ID 'X' in repository 'Y'. But adding, e.g., a branch with ID 'X' to repository 'Y' is acceptable. Only alphanumeric characters, and '~.-_', are allowed. Max length is 1024 characters */
              id: string
              /** List of issues keys that this entity is associated with. They must be valid JIRA issue keys. Minimum number of issue keys is 1. Maximum number of issue keys is 100 */
              issueKeys: string[]
              /** An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored. */
              updateSequenceId: number
              /** The status of the pull request. In the case of concurrent updates, priority is given in the order OPEN, MERGED, DECLINED, UNKNOWN */
              status: 'OPEN' | 'MERGED' | 'DECLINED' | 'UNKNOWN'
              /** Title of the pull request. Max length is 1024 characters */
              title: string
              /** The author of this pull request */
              author: {
                /** The name of this user in a format suitable for display. Max length is 255 characters */
                name: string
                /** The email address of the user, used to associate the user with a JIRA user. Max length is 255 characters */
                email?: string
                /** The username of the user, used to associate the user with a JIRA user if there are multiple users for a given email. Max length is 255 characters */
                username?: string
                /** The URL of the profile for this user. Max length is 1024 characters */
                url?: string
                /** The URL of the avatar for this user. Max length is 1024 characters */
                avatar?: string
              }
              /** The number of comments on the pull request */
              commentCount: number
              /** The name of the source branch of this PR. Max length is 255 characters */
              sourceBranch: string
              /** The url of the source branch of this PR. This is used to match this PR against the branch. Max length is 255 characters */
              sourceBranchUrl?: string
              /** The most recent update to this PR. Formatted as a UTC ISO 8601 date time format */
              lastUpdate: string
              /** The name of destination branch of this PR. Max length is 255 characters */
              destinationBranch?: string
              /** The list of reviewers of this pull request */
              reviewers?: {
                /** The name of this reviewer. Max length is 255 characters */
                name: string
                /** The approval status of this reviewer, default is UNAPPROVED */
                approvalStatus?: 'APPROVED' | 'UNAPPROVED'
                /** The URL of the profile for this reviewer. Max length is 1024 characters */
                url?: string
                /** The URL of the avatar for this reviewer. Max length is 1024 characters */
                avatar?: string
              }[]
              /** The URL of this pull request. Max length is 1024 characters */
              url: string
              /** Shortened identifier for this pull request, used for display. Max length is 255 characters */
              displayId: string
            }[]
            /** The URL of the avatar for this repository. Max length is 1024 characters */
            avatar?: string
            /** Description of the avatar for this repository. Max length is 1024 characters */
            avatarDescription?: string
            /** The ID of this entity. Will be used for cross entity linking. Must be unique by entity type within a repository, i.e., only one commit can have ID 'X' in repository 'Y'. But adding, e.g., a branch with ID 'X' to repository 'Y' is acceptable. Only alphanumeric characters, and '~.-_', are allowed. Max length is 1024 characters */
            id: string
            /** An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored. */
            updateSequenceId: number
          }
        }
      }
      /** Missing a OAuth token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `development information` permission. */
      403: unknown
      /** No data found for the given repository ID. */
      404: unknown
      /** API rate limit has been exceeded. */
      429: unknown
      /** An unknown error has occurred. */
      500: {
        content: {
          'application/json': {
            /** List of errors occurred. */
            errorMessages: {
              /** A human-readable message describing the error. */
              message: string
              /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
              errorTraceId?: string
            }[]
          }
        }
      }
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
    }
  }
  /** Deletes the repository data stored by the given ID and all related development information entities. Deletion is performed asynchronously. */
  deleteRepository: {
    parameters: {
      path: {
        /** The cloud ID of the site. */
        cloudId: string
        /** The ID of repository to delete */
        repositoryId: string
      }
      query: {
        /** An optional property to use to control deletion. Only stored data with an updateSequenceId less than or equal to that provided will be deleted. This can be used to help ensure submit/delete requests are applied correctly if they are issued close together. */
        _updateSequenceId?: number
      }
    }
    responses: {
      /** Delete request has been accepted. Data will eventually be removed from Jira if it exists. */
      202: unknown
      /** Missing a OAuth token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `development information` permission. */
      403: unknown
      /** API rate limit has been exceeded. */
      429: unknown
      /** An unknown error has occurred. */
      500: {
        content: {
          'application/json': {
            /** List of errors occurred. */
            errorMessages: {
              /** A human-readable message describing the error. */
              message: string
              /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
              errorTraceId?: string
            }[]
          }
        }
      }
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
    }
  }
  /** Deletes development information entities which have all the provided properties. Entities will be deleted that match ALL of the properties (i.e. treated as an AND). For example if request is DELETE bulk?accountId=123&projectId=ABC entities which have properties accountId=123 and projectId=ABC will be deleted. Special property '\_updateSequenceId' can be used to delete all entities with updateSequenceId less or equal than the value specified. In addition to the optional '\_updateSequenceId', one or more query params must be supplied to specify properties to delete by. Deletion is performed asynchronously: specified entities will eventually be removed from Jira. */
  deleteByProperties: {
    parameters: {
      path: {
        /** The cloud ID of the site. */
        cloudId: string
      }
      query: {
        /** An optional property to use to control deletion. Only stored data with an updateSequenceId less than or equal to that provided will be deleted. This can be used to help ensure submit/delete requests are applied correctly if they are issued close together. */
        _updateSequenceId?: number
      }
    }
    responses: {
      /** Delete accepted. Data will eventually be removed from Jira. */
      202: unknown
      /** Request has incorrect format. It will fail in the following cases: If no query properties are specified. If '_updateSequenceId' is not a numeric value. If multiple values of the same property key are specified. Deleting data for many property values, for the same property key, requires multiple requests to this resource. */
      400: {
        content: {
          'application/json': {
            /** List of errors occurred. */
            errorMessages: {
              /** A human-readable message describing the error. */
              message: string
              /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
              errorTraceId?: string
            }[]
          }
        }
      }
      /** Missing a OAuth token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `development information` permission. */
      403: unknown
      /** API rate limit has been exceeded. */
      429: unknown
      /** An unknown error has occurred. */
      500: {
        content: {
          'application/json': {
            /** List of errors occurred. */
            errorMessages: {
              /** A human-readable message describing the error. */
              message: string
              /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
              errorTraceId?: string
            }[]
          }
        }
      }
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
    }
  }
  /** Checks if development information which have all the provided properties exists. For example, if request is GET existsByProperties?accountId=123&projectId=ABC then result will be positive only if there is at least one entity or repository with both properties accountId=123 and projectId=ABC. Special property '\_updateSequenceId' can be used to filter all entities with updateSequenceId less or equal than the value specified. In addition to the optional '\_updateSequenceId', one or more query params must be supplied to specify properties to search by. */
  existsByProperties: {
    parameters: {
      path: {
        /** The cloud ID of the site. */
        cloudId: string
      }
      query: {
        /** An optional property. Filters out entities and repositories which have updateSequenceId greater than specified. */
        _updateSequenceId?: number
      }
    }
    responses: {
      /** Returns whether data exists for the specified properties. */
      200: {
        content: {
          'application/json': {
            /** Whether there is data matching the query */
            hasDataMatchingProperties?: boolean
          }
        }
      }
      /** Request has incorrect format. It will fail in the following cases: If no query properties are specified. If '_updateSequenceId' is not a numeric value. If multiple values of the same property key are specified. */
      400: {
        content: {
          'application/json': {
            /** List of errors occurred. */
            errorMessages: {
              /** A human-readable message describing the error. */
              message: string
              /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
              errorTraceId?: string
            }[]
          }
        }
      }
      /** Missing a OAuth token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `development information` permission. */
      403: unknown
      /** API rate limit has been exceeded. */
      429: unknown
      /** An unknown error has occurred. */
      500: {
        content: {
          'application/json': {
            /** List of errors occurred. */
            errorMessages: {
              /** A human-readable message describing the error. */
              message: string
              /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
              errorTraceId?: string
            }[]
          }
        }
      }
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
    }
  }
  /** Deletes particular development information entity. Deletion is performed asynchronously. */
  deleteEntity: {
    parameters: {
      path: {
        /** The cloud ID of the site. */
        cloudId: string
        repositoryId: string
        entityType: 'commit' | 'branch' | 'pull_request'
        entityId: string
      }
      query: {
        /** An optional property to use to control deletion. Only stored data with an updateSequenceId less than or equal to that provided will be deleted. This can be used to help ensure submit/delete requests are applied correctly if they are issued close together. */
        _updateSequenceId?: number
      }
    }
    responses: {
      /** Delete request has been accepted. Data will eventually be removed from Jira if it exists. */
      202: unknown
      /** Wrong entity type specified */
      400: {
        content: {
          'application/json': {
            /** List of errors occurred. */
            errorMessages: {
              /** A human-readable message describing the error. */
              message: string
              /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
              errorTraceId?: string
            }[]
          }
        }
      }
      /** Missing a OAuth token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `development information` permission. */
      403: unknown
      /** API rate limit has been exceeded. */
      429: unknown
      /** An unknown error has occurred. */
      500: {
        content: {
          'application/json': {
            /** List of errors occurred. */
            errorMessages: {
              /** A human-readable message describing the error. */
              message: string
              /** An optional trace ID that can be used by Jira developers to locate the source of the error. */
              errorTraceId?: string
            }[]
          }
        }
      }
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
    }
  }
  /**
   * Update / insert deployment data.
   *
   * Deployments are identified by the combination of `pipelineId`, `environmentId` and `deploymentSequenceNumber`, and existing deployment data for the same deployment will be replaced if it exists and the `updateSequenceNumber` of existing data is less than the incoming data.
   *
   * Submissions are processed asynchronously. Submitted data will eventually be available in Jira. Most updates are available within a short period of time, but may take some time during peak load and/or maintenance times. The `getDeploymentByKey` operation can be used to confirm that data has been stored successfully (if needed).
   *
   * In the case of multiple deployments being submitted in one request, each is validated individually prior to submission. Details of which deployments failed submission (if any) are available in the response object.
   *
   * Only on-premise integrations apps that define the `deployment` permission can access this resource.
   */
  submitDeployments: {
    responses: {
      /**
       * Submission accepted. Each submitted deployment that is of a valid format will eventually be available in Jira.
       *
       * Details of which deployments were submitted and which failed submission (due to data format problems etc.) are available in the response object.
       */
      202: {
        content: {
          'application/json': components['schemas']['SubmitDeploymentsResponse']
        }
      }
      /**
       * Request has incorrect format.
       *
       * Note that in the case of an individual deployment having an invalid format (rather than the request as a whole) the response for the request will be a 202 and details of the invalid deployment will be contained in the response object.
       */
      400: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
      /** Missing a OAuth token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `deployment information` permission. */
      403: unknown
      /** Data is too large. Submit fewer deployments in each payload. */
      413: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
      /** API rate limit has been exceeded. */
      429: unknown
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
      /** An unknown error has occurred. */
      default: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
    }
    /** Deployment data to submit. */
    requestBody: {
      content: {
        'application/json': components['schemas']['SubmitDeploymentRequest']
      }
    }
  }
  /**
   * Bulk delete all deployments that match the given request.
   *
   * In addition to the optional `_updateSequenceNumber`, one or more query params must be supplied to specify the Properties to delete by.
   * If more than one Property is provided, data will be deleted that matches ALL of the Properties (i.e. treated as AND).
   * See the documentation for the `submitDeployments` operation for more details.
   *
   * Example operation: DELETE /bulkByProperties?accountId=account-123&createdBy=user-456
   *
   * Deletion is performed asynchronously. The `getDeploymentByKey` operation can be used to confirm that data has been deleted successfully (if needed).
   *
   * Only on-premise integrations apps that define the `deployment` permission can access this resource.
   */
  deleteDeploymentsByProperty: {
    parameters: {
      query: {
        /**
         * An optional `updateSequenceNumber` to use to control deletion.
         *
         * Only stored data with an `updateSequenceNumber` less than or equal to that provided will be deleted.
         * This can be used help ensure submit/delete requests are applied correctly if issued close together.
         *
         * If not provided, all stored data that matches the request will be deleted.
         */
        _updateSequenceNumber?: number
      }
    }
    responses: {
      /** Delete accepted. Data will eventually be removed from Jira. */
      202: unknown
      /** Request has incorrect format (e.g. missing at least one Property param). */
      400: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
      /** Missing a OAuth token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `deployment information` permission. */
      403: unknown
      /** API rate limit has been exceeded. */
      429: unknown
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
      /** An unknown error has occurred. */
      default: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
    }
  }
  /**
   * Retrieve the currently stored deployment data for the given `pipelineId`, `environmentId` and `deploymentSequenceNumber` combination.
   *
   * The result will be what is currently stored, ignoring any pending updates or deletes.
   *
   * Only on-premise integrations apps that define the `deployment` permission can access this resource.
   */
  getDeploymentByKey: {
    parameters: {
      path: {
        /** The ID of the deployment's pipeline. */
        pipelineId: string
        /** The ID of the deployment's environment. */
        environmentId: string
        /** The deployment's deploymentSequenceNumber. */
        deploymentSequenceNumber: number
      }
    }
    responses: {
      /** The deployment data currently stored for the given ID. */
      200: {
        content: {
          'application/json': components['schemas']['DeploymentData']
        }
      }
      /** Missing a OAuth token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `deployment information` permission. */
      403: unknown
      /** No data found for the given deployment ID. */
      404: unknown
      /** API rate limit has been exceeded. */
      429: unknown
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
      /** An unknown error has occurred. */
      default: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
    }
  }
  /**
   * Delete the currently stored deployment data for the given `pipelineId`, `environmentId` and `deploymentSequenceNumber` combination.
   *
   * Deletion is performed asynchronously. The `getDeploymentByKey` operation can be used to confirm that data has been deleted successfully (if needed).
   *
   * Only on-premise integrations apps that define the `deployment` permission can access this resource.
   */
  deleteDeploymentByKey: {
    parameters: {
      path: {
        /** The ID of the deployment's pipeline. */
        pipelineId: string
        /** The ID of the deployment's environment. */
        environmentId: string
        /** The deployment's deploymentSequenceNumber. */
        deploymentSequenceNumber: number
      }
      query: {
        /**
         * An optional `_updateSequenceNumber` to use to control deletion.
         *
         * Only stored data with an `updateSequenceNumber` less than or equal to that provided will be deleted.
         * This can be used help ensure submit/delete requests are applied correctly if issued close together.
         */
        _updateSequenceNumber?: number
      }
    }
    responses: {
      /** Delete has been accepted. Data will eventually be removed from Jira if it exists. */
      202: unknown
      /** Missing a OAuth token, or token is invalid. */
      401: unknown
      /** The OAuth token used does not correspond to an app that defines the `deployment information` permission. */
      403: unknown
      /** API rate limit has been exceeded. */
      429: unknown
      /** Service is unavailable due to maintenance or other reasons. */
      503: unknown
      /** An unknown error has occurred. */
      default: {
        content: {
          'application/json': components['schemas']['ErrorMessages']
        }
      }
    }
  }
}

export type external = {}
